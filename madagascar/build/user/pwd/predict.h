/* This file is automatically generated. DO NOT EDIT! */

#ifndef _predict_h
#define _predict_h


#include <rsf.h>


void predict_init (int nx, int ny /* data size */, 
		   float e        /* regularization parameter */,
		   int nw         /* accuracy order */,
		   int k          /* radius */,
		   bool two       /* if two predictions */);
/*< initialize >*/


void predict_close (void);
/*< free allocated storage >*/


void predict_step(bool adj            /* adjoint flag */,
		  bool forw           /* forward or backward */, 
		  float* trace        /* input/output trace */,
		  const float* pp    /* slope */);
/*< prediction step >*/


void predict1_step(bool forw      /* forward or backward */, 
		   float* trace1  /* input trace */,
		   const float* pp /* slope */,
		   float* trace /* output trace */);
/*< prediction step from one trace >*/


void predict2_step(bool forw1        /* forward or backward */, 
		   bool forw2,
		   float* trace1     /* input trace */,
		   float* trace2,
		   const float* pp1  /* slope */,
		   const float* pp2,
		   float *trace      /* output trace */);
/*< prediction step from two traces>*/


void predict_set(float **dip1 /* dip field [n2][n1] */);
/*< set the local slopes for applying the linear operator >*/


void predict_lop(bool adj, bool add, int nx, int ny, float *xx, float *yy);
/*< linear operator >*/


void predicter_lop(bool adj, bool add, int nx, int ny, float *xx, float *yy);
/*< linear operator >*/


void subtracter_lop(bool adj, bool add, int nx, int ny, float *xx, float *yy);
/*< linear operator >*/


void subtract_lop(bool adj, bool add, int nx, int ny, float *xx, float *yy);
/*< linear operator >*/

#endif
