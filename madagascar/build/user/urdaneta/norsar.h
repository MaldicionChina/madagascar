/* This file is automatically generated. DO NOT EDIT! */

#ifndef _norsar_h
#define _norsar_h


#include "norgen.h"


void norsar_init(int gnx1, int gnz1,
		 float TETAMAX, int N, float alpha2, int inter, 
		 int nx, int nz, float ox, float oz, float dx, float dz,
		 struct point length);
/*< initialize >*/


void initial (struct point pos, struct heptagon *cube, float *vel, 
	      float dt, int nt, float T, int lomx, int nr, struct grid *out);
/*<
* This subroutine initializes "cube", a structure array that contains:
* the location of the points over the wavefront at a time t,
* take-off angles from these points, the ending points over the
* wavefront at a time t + nt*dt and a flag (which tells if the ray
* belongs to a caustic or if its out of bounds).
*
* cube[].x0		position of source on wavefront at time t
*			cube[].x0 and cube[].x1 are point structures;
*			i.e., they an x and z components.
*			
* cube[].angle		arriving angle from cube[].x1.x, cube[].x1.z
* cube[].ampl		amplitude
* cube[].x1		position of arriving ray on wavefront at time t + dt
* cube[].cf		flag
*
* cube is rewritten every time a wavefront is propagated.
*
* The number of elements of cube needs to be, as big as the number 
* of points on the wavefront. Notice that there is no way to estimate
* this number a priori, so a rough estimate for a higher bound should
* be given at the beginning of the program (nrmax).
>*/


void wavefront (struct heptagon *cube, int nr, float *vel, 
		float dt, int nt, float T, int lomx);
/*<
* This subroutine propagates the wavefront, i.e; computes points over 
* the next wavefront. wavefront uses subroutine lomax which prototype 
* is explained here:
*
*
* void lomax (point, take-off angle, velocity model, time step,
*		number of time steps, period, array that stores
*		values passed back by lomax)
*
* The subroutine "lomax" propagates a waveray of a given period,
* through the velocity model starting from a source location x,z
* at a given take-off angle. It computes the ending location x',z' 
* and its landing angle, after a nt*dt time. The ouput is given
* by the array ra[].
*
* ra[0] = arriving angle of ray at x', z'
* ra[1] = x' position of ray
* ra[2] = z' position of ray
*
>*/


void mark_pts_outofbounds (struct heptagon *cube, int nr, float x0, float x1, float z0, float z1);
/*< "mark_pts_outofbounds" raises a flag on any point of the wavefront 
* that goes out of bounds. The boundary is define by points x0, x1,
* z0, z1. >*/


void makeup (struct heptagon *cube, int *nr);
/*< "makeup" takes off, from the wavefront, any point that goes
 * out of boundaries or that belongs to a caustic. >*/


void amplitudes (struct heptagon *cube,int  nr);
/*< This subroutine obtains the amplitudes of the new wavefront
* by calculating the geometrical spreading factor and 
* multiplying it with the old amplitude value.
*
* Notice that in order to calculate the amplitude for ending
* points of the wavefront; i.e., ii==0 or ii==nr-1, the code
* "wraps" to the other end of the wavefront by using moduli
* nr. >*/


void interpolation (struct heptagon *cube, int *nr, int nrmax, float DSmax);
/*< interpolation checks the distance between two contiguos points in
* the wavefront, if its bigger than DSmax, then it calculates how
* many rays does it has to interpolate in between.
*
* interpolation calls a pair of subroutines which lay in ./interp.c
* Both subroutines use a third order polynome interpolation. >*/

#endif
